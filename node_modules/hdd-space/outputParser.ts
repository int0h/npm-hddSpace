function genFinder(headerLine: string, name: string, align: string, re: RegExp){    
    let offset = headerLine.indexOf(name);
    switch (align){
        case "left": 
            break;
        case "right": 
            offset += name.length; 
            break;
        default: 
            throw new Error(align + ' align not supported');
    };
    const newReSource = align === "left"
        ? '^' + re.source
        : re.source + '$';
    let newRe = new RegExp(newReSource, 'gim');
    return function(line: string){
        const edgeStr = align === "left"
            ? line.slice(offset)
            : line.slice(0, offset);
        newRe.lastIndex = 0;
        const found = newRe.exec(edgeStr);
        if (!found){
            return undefined;
        };
        return found[0];
    };
};

export interface IRuleSet {
    [key: string]: {
        name: string;
        align: string;
        re: RegExp;
    }
};

export function parseOutput(rules: IRuleSet, output: string){
    let lines = output.trim().split('\n');
    const headerLine = lines.shift() as string;
    const lookFor: any = {};
    for (let i in rules){
        if (!rules.hasOwnProperty(i)){
            continue;
        };
        var rule = rules[i];
        lookFor[i] = genFinder(headerLine, rule.name, rule.align, rule.re);
    };
    return lines.map(function(line){
        var res: any = {};
        for (var i in lookFor){
            res[i] = lookFor[i](line);
        };
        return res;
    });
};